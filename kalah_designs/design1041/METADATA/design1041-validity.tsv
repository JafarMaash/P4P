#TITLE	Coupling Validity Study
#SUMMARY	Measurements for the metrics used in the Coupling Validity Study: Paul Ralph and Ewan Tempero Construct Validity in Software Engineering Research and Software Metrics 22nd International Conference on Evaluation and Assessment in Software Engineering (EASE) 2018. https://doi.org/10.1145/3210459.3210461

##Dataset attributes
Timestamp	Sun Apr 24 08:49:30 NZST 2022
Tool	mete-analysis(coupling validity):20200425
System	design1041
Codebase	../grad006-03/design1041/design1041

##Measurements
#Metadata
Kind	Nominal	What 'kind' of module (Class, Interface, Enum, Annotation, Exception)
FAN-out (Coupling)	UnboundedCount	(trgtdcl) Only record dependencies to target modules whose declarations have been seen; (srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (trgtsttic) Record dependencies to both instance and static fields and methods in the target module; (srccons) Consider constructors as invokers as creating coupling; (trgtcons) Record both invoking methods and calling construtors as creating dependencies; (type) Record dependencies between all types, including interfaces, enums, an annotations; (anc) Include dependencies to ancestors of source; (desc) Include descendants to ancestors of source; (inh) Include dependencies on targets whose accessed members were inherited; (nopoly) Do not record dependencies on targets whose members were accessed via polymorphism; (unidir) Dependencies are recorded as uni-directional, only from source to target.; (fanout) Record only dependencies from source to target (no-op when bidir); (mod) Record dependencies between modules (as opposed to between packages); (pres) Record only the presence (or not) of an occurrence of a dependency between entities; (atom) Consider only top-level types as atomic (nested types are not separate); (raw) Do not record dependencies due to synthetic constructs
FAN-in (Coupling)	UnboundedCount	(trgtdcl) Only record dependencies to target modules whose declarations have been seen; (srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (trgtsttic) Record dependencies to both instance and static fields and methods in the target module; (srccons) Consider constructors as invokers as creating coupling; (trgtcons) Record both invoking methods and calling construtors as creating dependencies; (type) Record dependencies between all types, including interfaces, enums, an annotations; (anc) Include dependencies to ancestors of source; (desc) Include descendants to ancestors of source; (inh) Include dependencies on targets whose accessed members were inherited; (nopoly) Do not record dependencies on targets whose members were accessed via polymorphism; (unidir) Dependencies are recorded as uni-directional, only from source to target.; (fanin) Record only dependencies from target to source (no-op when bidir); (mod) Record dependencies between modules (as opposed to between packages); (pres) Record only the presence (or not) of an occurrence of a dependency between entities; (atom) Consider only top-level types as atomic (nested types are not separate); (raw) Do not record dependencies due to synthetic constructs
FAN-bidir (Coupling)	UnboundedCount	(trgtdcl) Only record dependencies to target modules whose declarations have been seen; (srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (trgtsttic) Record dependencies to both instance and static fields and methods in the target module; (srccons) Consider constructors as invokers as creating coupling; (trgtcons) Record both invoking methods and calling construtors as creating dependencies; (type) Record dependencies between all types, including interfaces, enums, an annotations; (anc) Include dependencies to ancestors of source; (desc) Include descendants to ancestors of source; (inh) Include dependencies on targets whose accessed members were inherited; (nopoly) Do not record dependencies on targets whose members were accessed via polymorphism; (bidir) Dependencies are recorded as bi-directional. If A has a dependency to B, then B has a dependency to A; (fanout) Record only dependencies from source to target (no-op when bidir); (mod) Record dependencies between modules (as opposed to between packages); (pres) Record only the presence (or not) of an occurrence of a dependency between entities; (atom) Consider only top-level types as atomic (nested types are not separate); (raw) Do not record dependencies due to synthetic constructs
FAN-out-occr (Coupling)	UnboundedCount	(trgtdcl) Only record dependencies to target modules whose declarations have been seen; (srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (trgtsttic) Record dependencies to both instance and static fields and methods in the target module; (srccons) Consider constructors as invokers as creating coupling; (trgtcons) Record both invoking methods and calling construtors as creating dependencies; (type) Record dependencies between all types, including interfaces, enums, an annotations; (anc) Include dependencies to ancestors of source; (desc) Include descendants to ancestors of source; (inh) Include dependencies on targets whose accessed members were inherited; (nopoly) Do not record dependencies on targets whose members were accessed via polymorphism; (unidir) Dependencies are recorded as uni-directional, only from source to target.; (fanout) Record only dependencies from source to target (no-op when bidir); (mod) Record dependencies between modules (as opposed to between packages); (occr) Record each occurrence of a dependency separately; (atom) Consider only top-level types as atomic (nested types are not separate); (raw) Do not record dependencies due to synthetic constructs
CBO (Coupling)	UnboundedCount	(trgtdcl) Only record dependencies to target modules whose declarations have been seen; (srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (trgtsttic) Record dependencies to both instance and static fields and methods in the target module; (srccons) Consider constructors as invokers as creating coupling; (trgtcons) Record both invoking methods and calling construtors as creating dependencies; (type) Record dependencies between all types, including interfaces, enums, an annotations; (anc) Include dependencies to ancestors of source; (desc) Include descendants to ancestors of source; (inh) Include dependencies on targets whose accessed members were inherited; (nopoly) Do not record dependencies on targets whose members were accessed via polymorphism; (bidir) Dependencies are recorded as bi-directional. If A has a dependency to B, then B has a dependency to A; (fanout) Record only dependencies from source to target (no-op when bidir); (mod) Record dependencies between modules (as opposed to between packages); (pres) Record only the presence (or not) of an occurrence of a dependency between entities; (atom) Consider only top-level types as atomic (nested types are not separate); (raw) Do not record dependencies due to synthetic constructs
CBO-out (Coupling)	UnboundedCount	(trgtdcl) Only record dependencies to target modules whose declarations have been seen; (srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (trgtsttic) Record dependencies to both instance and static fields and methods in the target module; (srccons) Consider constructors as invokers as creating coupling; (trgtcons) Record both invoking methods and calling construtors as creating dependencies; (type) Record dependencies between all types, including interfaces, enums, an annotations; (anc) Include dependencies to ancestors of source; (desc) Include descendants to ancestors of source; (inh) Include dependencies on targets whose accessed members were inherited; (nopoly) Do not record dependencies on targets whose members were accessed via polymorphism; (unidir) Dependencies are recorded as uni-directional, only from source to target.; (fanout) Record only dependencies from source to target (no-op when bidir); (mod) Record dependencies between modules (as opposed to between packages); (pres) Record only the presence (or not) of an occurrence of a dependency between entities; (atom) Consider only top-level types as atomic (nested types are not separate); (raw) Do not record dependencies due to synthetic constructs
MPC (Coupling)	UnboundedCount	(trgtdcl) Only record dependencies to target modules whose declarations have been seen; (pres) Record only the presence (or not) of an occurrence of a dependency between entities
ICP (Coupling)	UnboundedCount	(trgtdcl) Only record dependencies to target modules whose declarations have been seen
LCOM1 (Cohesion)	UnboundedCount	(srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (srccons) Consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (srcmem) Include dependencies to members of all visibilities in source
LCOM1-inst (Cohesion)	UnboundedCount	(srcinst) Only record dependencies with respect to instance fields and methods in the source module; (srccons) Consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (srcmem) Include dependencies to members of all visibilities in source
LCOM2 (Cohesion)	UnboundedCount	(srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (srccons) Consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (srcmem) Include dependencies to members of all visibilities in source
LCOM2-inst (Cohesion)	UnboundedCount	(srcinst) Only record dependencies with respect to instance fields and methods in the source module; (srccons) Consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (srcmem) Include dependencies to members of all visibilities in source
LCOM4 (Cohesion)	UnboundedCount	(Can't provide easy evidence for number of connected components) (srcinst) Only record dependencies with respect to instance fields and methods in the source module; (srccons) Consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (srcmem) Include dependencies to members of all visibilities in source
NumMeth (Size)	UnboundedCount	(srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (srccons) Consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (raw) Do not record dependencies due to synthetic constructs; (srcmem) Include dependencies to members of all visibilities in source
NumFlds(Size)	UnboundedCount	(trgtall) Record dependencies to target modules whether or not the declarations have been seen; (srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (type) Record dependencies between all types, including interfaces, enums, an annotations; (occr) Record each occurrence of a dependency separately; (prim) Include dependencies to primitive types; (same) Include dependencies to the same type
#Data
#Entity	Kind	Evidence	FAN-out (Coupling)	Evidence	FAN-in (Coupling)	Evidence	FAN-bidir (Coupling)	Evidence	FAN-out-occr (Coupling)	Evidence	CBO (Coupling)	Evidence	CBO-out (Coupling)	Evidence	MPC (Coupling)	Evidence	ICP (Coupling)	Evidence	LCOM1 (Cohesion)	Evidence	LCOM1-inst (Cohesion)	Evidence	LCOM2 (Cohesion)	Evidence	LCOM2-inst (Cohesion)	Evidence	LCOM4 (Cohesion)	Evidence	NumMeth (Size)	Evidence	NumFlds(Size)	Evidence
kalah.Board	Class	(not needed)	2	[print.BoardPrinter, kalah.Row]	1	[kalah.Kalah]	3	[print.BoardPrinter, kalah.Row, kalah.Kalah]	16	[kalah.Board#private final kalah.Row[] rows, kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}>print.BoardPrinter#public void printResult(com.qualitascorpus.testsupport.IO,int[]) {}:[5], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>kalah.Row#public int getStore() {}:[6], kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}>kalah.Row#public int getScore() {}:[3], kalah.Board#public boolean doMove(int) {}>kalah.Row#public int takeSeeds(int) {}:[5], kalah.Board#private final print.BoardPrinter printer, kalah.Board#public <init>(int,int,int,print.BoardPrinter) {}>kalah.Row#public <init>(int,int) {}:[7], kalah.Board#public boolean isGameOver() {}>kalah.Row#public int[] getHouses() {}:[3], kalah.Board#public boolean doMove(int) {}>kalah.Row#public void addToStore(int) {}:[17], Local:kalah.Row:[3], Parameter:kalah.Board#public <init>(int,int,int,print.BoardPrinter) {}>print.BoardPrinter:[3], kalah.Board#public boolean doMove(int) {}>kalah.Row#public int takeSeeds(int) {}:[16], kalah.Board#public boolean doMove(int) {}>kalah.Row#public int takeSeeds(int) {}:[15], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>print.BoardPrinter#public abstract void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) <>:[8], kalah.Board#public boolean doMove(int) {}>kalah.Row#public int insertSeed(int) {}:[10], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>kalah.Row#public int[] getHouses() {}:[4]]	3	[print.BoardPrinter, kalah.Row, kalah.Kalah]	2	[print.BoardPrinter, kalah.Row]	11	[doMove(int)>kalah.Row#public int takeSeeds(int) {}, printState(com.qualitascorpus.testsupport.IO)>kalah.Row#public int getStore() {}, printState(com.qualitascorpus.testsupport.IO)>print.TwoPlayerBoardPrinter#public void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) {}, doMove(int)>kalah.Row#public int insertSeed(int) {}, isGameOver()>kalah.Row#public int[] getHouses() {}, printResult(com.qualitascorpus.testsupport.IO)>print.BoardPrinter#public void printResult(com.qualitascorpus.testsupport.IO,int[]) {}, printState(com.qualitascorpus.testsupport.IO)>kalah.Row#public int[] getHouses() {}, printState(com.qualitascorpus.testsupport.IO)>print.BoardPrinter#public abstract void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) <>, printResult(com.qualitascorpus.testsupport.IO)>kalah.Row#public int getScore() {}, doMove(int)>kalah.Row#public void addToStore(int) {}, <init>(int,int,int,print.BoardPrinter)>kalah.Row#public <init>(int,int) {}]	25	[kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>kalah.Row#public int getStore() {}:[6], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>print.BoardPrinter#public abstract void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) <>:[8][2]int[], kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}>kalah.Row#public int getScore() {}:[3], kalah.Board#public boolean doMove(int) {}>kalah.Row#public int takeSeeds(int) {}:[5], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>print.TwoPlayerBoardPrinter#public void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) {}:[8][0]com.qualitascorpus.testsupport.IO, kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>print.TwoPlayerBoardPrinter#public void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) {}:[8][1]int[][], kalah.Board#public boolean isGameOver() {}>kalah.Row#public int[] getHouses() {}:[3], kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}>print.BoardPrinter#public void printResult(com.qualitascorpus.testsupport.IO,int[]) {}:[5][1]int[], kalah.Board#public boolean doMove(int) {}>kalah.Row#public int takeSeeds(int) {}:[15][0]int, kalah.Board#public boolean doMove(int) {}>kalah.Row#public int takeSeeds(int) {}:[16][0]int, kalah.Board#public boolean doMove(int) {}>kalah.Row#public int takeSeeds(int) {}:[15], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>print.BoardPrinter#public abstract void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) <>:[8], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>print.TwoPlayerBoardPrinter#public void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) {}:[8][2]int[], kalah.Board#public boolean doMove(int) {}>kalah.Row#public void addToStore(int) {}:[17][0]int, kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}>print.BoardPrinter#public void printResult(com.qualitascorpus.testsupport.IO,int[]) {}:[5], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>print.BoardPrinter#public abstract void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) <>:[8][1]int[][], kalah.Board#public boolean doMove(int) {}>kalah.Row#public int insertSeed(int) {}:[10][0]int, kalah.Board#public boolean doMove(int) {}>kalah.Row#public void addToStore(int) {}:[17], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>print.BoardPrinter#public abstract void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) <>:[8][0]com.qualitascorpus.testsupport.IO, kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}>print.BoardPrinter#public void printResult(com.qualitascorpus.testsupport.IO,int[]) {}:[5][0]com.qualitascorpus.testsupport.IO, kalah.Board#public boolean doMove(int) {}>kalah.Row#public int takeSeeds(int) {}:[16], kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>print.TwoPlayerBoardPrinter#public void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) {}:[8], kalah.Board#public boolean doMove(int) {}>kalah.Row#public int insertSeed(int) {}:[10], kalah.Board#public boolean doMove(int) {}>kalah.Row#public int takeSeeds(int) {}:[5][0]int, kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}>kalah.Row#public int[] getHouses() {}:[4]]	7	[kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public int getPlayer() {}, kalah.Board#public int getPlayer() {}>>>kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}, kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}, kalah.Board#public int getPlayer() {}>>>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}, kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public boolean doMove(int) {}, kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}, kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public boolean isGameOver() {}]	7	[kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public int getPlayer() {}, kalah.Board#public int getPlayer() {}>>>kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}, kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}, kalah.Board#public int getPlayer() {}>>>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}, kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public boolean doMove(int) {}, kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}, kalah.Board#private int getNextPlayer(int,int) {}>>>kalah.Board#public boolean isGameOver() {}]	0	[]	0	[]	1	[kalah.Board#public boolean isGameOver() {}]	7	[kalah.Board#public <init>(int,int,int,print.BoardPrinter) {}>java.lang.Object#public <init>() <>*:[1], Return:kalah.Board#public int getPlayer() {}, Return:kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}, Return:kalah.Board#public boolean doMove(int) {}, Return:kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}, Return:kalah.Board#private int getNextPlayer(int,int) {}, Return:kalah.Board#public boolean isGameOver() {}]	5	[kalah.Board#private final kalah.Row[] rows, kalah.Board#private final int numHouses, kalah.Board#private static final int NUM_PLAYERS, kalah.Board#private final print.BoardPrinter printer, kalah.Board#private int playerTurn]
kalah.Kalah	Class	(not needed)	3	[print.BoardPrinter, print.TwoPlayerBoardPrinter, kalah.Board]	0	[]	3	[print.BoardPrinter, print.TwoPlayerBoardPrinter, kalah.Board]	10	[kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}:[3], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public int getPlayer() {}:[9], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public boolean doMove(int) {}:[16], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}:[6], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>print.TwoPlayerBoardPrinter#public <init>() {}:[1], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}:[15], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public boolean isGameOver() {}:[4], Local:print.BoardPrinter:[1], Local:kalah.Board:[2], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public <init>(int,int,int,print.BoardPrinter) {}:[2]]	2	[print.TwoPlayerBoardPrinter, kalah.Board]	2	[print.TwoPlayerBoardPrinter, kalah.Board]	7	[play(com.qualitascorpus.testsupport.IO)>kalah.Board#public boolean doMove(int) {}, play(com.qualitascorpus.testsupport.IO)>print.TwoPlayerBoardPrinter#public <init>() {}, play(com.qualitascorpus.testsupport.IO)>kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}, play(com.qualitascorpus.testsupport.IO)>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}, play(com.qualitascorpus.testsupport.IO)>kalah.Board#public <init>(int,int,int,print.BoardPrinter) {}, play(com.qualitascorpus.testsupport.IO)>kalah.Board#public int getPlayer() {}, play(com.qualitascorpus.testsupport.IO)>kalah.Board#public boolean isGameOver() {}]	10	[kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}:[3], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}:[3][0]com.qualitascorpus.testsupport.IO, kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public boolean doMove(int) {}:[16][0]int, kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public int getPlayer() {}:[9], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public boolean doMove(int) {}:[16], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}:[6], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}:[15], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public boolean isGameOver() {}:[4], kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public void printState(com.qualitascorpus.testsupport.IO) {}:[15][0]com.qualitascorpus.testsupport.IO, kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}>kalah.Board#public void printResult(com.qualitascorpus.testsupport.IO) {}:[6][0]com.qualitascorpus.testsupport.IO]	1	[kalah.Kalah#public static void main(java.lang.String[]) {}>>>kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}]	0	[]	1	[value0]	0	[]	1	[kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}]	3	[Return:kalah.Kalah#public static void main(java.lang.String[]) {}, kalah.Kalah#public <init>() {}>java.lang.Object#public <init>() <>*:[1], Return:kalah.Kalah#public void play(com.qualitascorpus.testsupport.IO) {}]	5	[kalah.Kalah#private static final int QUIT_VALUE, kalah.Kalah#private static final int STARTING_PLAYER, kalah.Kalah#private static final int NUM_HOUSES, kalah.Kalah#private static final java.lang.String QUIT_STRING, kalah.Kalah#private static final int NUM_SEEDS]
kalah.Row	Class	(not needed)	0	[]	1	[kalah.Board]	1	[kalah.Board]	0	[]	1	[kalah.Board]	0	[]	0	[]	0	[]	4	[kalah.Row#public int getStore() {}>>>kalah.Row#public int takeSeeds(int) {}, kalah.Row#public int getStore() {}>>>kalah.Row#public int[] getHouses() {}, kalah.Row#public int[] getHouses() {}>>>kalah.Row#public void addToStore(int) {}, kalah.Row#public int takeSeeds(int) {}>>>kalah.Row#public void addToStore(int) {}]	4	[kalah.Row#public int getStore() {}>>>kalah.Row#public int takeSeeds(int) {}, kalah.Row#public int getStore() {}>>>kalah.Row#public int[] getHouses() {}, kalah.Row#public int[] getHouses() {}>>>kalah.Row#public void addToStore(int) {}, kalah.Row#public int takeSeeds(int) {}>>>kalah.Row#public void addToStore(int) {}]	0	[]	0	[]	1	[kalah.Row#public int takeSeeds(int) {}]	7	[Return:kalah.Row#public int getScore() {}, Return:kalah.Row#public int takeSeeds(int) {}, Return:kalah.Row#public int insertSeed(int) {}, Return:kalah.Row#public void addToStore(int) {}, kalah.Row#public <init>(int,int) {}>java.lang.Object#public <init>() <>*:[1], Return:kalah.Row#public int[] getHouses() {}, Return:kalah.Row#public int getStore() {}]	2	[kalah.Row#private int store, kalah.Row#private int[] houses]
print.BoardPrinter	Abstract	(not needed)	0	[]	3	[print.TwoPlayerBoardPrinter, kalah.Kalah, kalah.Board]	3	[print.TwoPlayerBoardPrinter, kalah.Kalah, kalah.Board]	0	[]	2	[print.TwoPlayerBoardPrinter, kalah.Board]	0	[]	0	[]	0	[]	0	[]	0	[]	0	[]	0	[]	2	[print.BoardPrinter#public abstract void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) <>, print.BoardPrinter#public void printResult(com.qualitascorpus.testsupport.IO,int[]) {}]	4	[print.BoardPrinter#public <init>() {}>java.lang.Object#public <init>() <>*:[1], Return:print.BoardPrinter#public abstract void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) <>, Return:print.BoardPrinter#protected int convertToPrintValue(int) {}, Return:print.BoardPrinter#public void printResult(com.qualitascorpus.testsupport.IO,int[]) {}]	0	[]
print.TwoPlayerBoardPrinter	Class	(not needed)	1	[print.BoardPrinter]	1	[kalah.Kalah]	2	[print.BoardPrinter, kalah.Kalah]	3	[print.TwoPlayerBoardPrinter#private java.lang.String formatHouseString(java.lang.String,int,int) {}>print.BoardPrinter#protected int convertToPrintValue(int) {}:[1], print.TwoPlayerBoardPrinter#public <init>() {}>print.BoardPrinter#public <init>() {}:[1], Extends:print.TwoPlayerBoardPrinter>print.BoardPrinter]	2	[print.BoardPrinter, kalah.Kalah]	1	[print.BoardPrinter]	1	[<init>()>print.BoardPrinter#public <init>() {}]	2	[print.TwoPlayerBoardPrinter#private java.lang.String formatHouseString(java.lang.String,int,int) {}>print.BoardPrinter#protected int convertToPrintValue(int) {}:[1], print.TwoPlayerBoardPrinter#private java.lang.String formatHouseString(java.lang.String,int,int) {}>print.BoardPrinter#protected int convertToPrintValue(int) {}:[1][0]int]	0	[]	0	[]	0	[]	0	[]	1	[print.TwoPlayerBoardPrinter#public void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) {}]	5	[Return:print.TwoPlayerBoardPrinter#private java.lang.String leftPad(int) {}, Return:print.TwoPlayerBoardPrinter#public void printState(com.qualitascorpus.testsupport.IO,int[][],int[]) {}, Return:print.TwoPlayerBoardPrinter#private java.lang.String formatHouseString(java.lang.String,int,int) {}, print.TwoPlayerBoardPrinter#public <init>() {}>print.BoardPrinter#public <init>() {}:[1], Return:print.TwoPlayerBoardPrinter#private void trim(java.lang.StringBuilder) {}]	0	[]
